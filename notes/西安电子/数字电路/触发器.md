---
id: "触发器"
aliases:
  - "触发器"
tags: []
---

# 触发器

## 触发器基础

双稳态电路, 可以做到很好的保持

![zz](img/image_2023-10-23-10-21-27.png)

#### 改变存储的值(增加开关) CMOS控制的触发器的原理

![zz](img/image_2023-10-23-10-23-13.png)

#### 改变存储的值(增加输入) 门级触发器

![zz](img/image_2023-10-23-10-23-59.png)

#### 改画一下

![zz](img/image_2023-10-23-10-25-27.png)

## 门级触发器

### 基本RS触发器

- 输出端, 一组互补的输出

- 输入端
  - 置位端S_D (低电平有效, 因为是由与非门组成)
  - 复位端R_D

定义:

1. "1状态"
2. "0状态"
3. 次太Q^(n+1), 现太Q^(n)

#### S_D=0, R_D=1 => Q=1, ~Q=0 => "1状态" (接收)

![zz](img/image_2023-10-23-10-39-20.png)

S_D=0, 与门对0敏感, 那么Q=1, 然后传递另一个与门

这个主要原理就是: 与门对0敏感

#### S_D=1, R_D=0 => Q=0, ~Q=1 => "1状态" (接收)

同理

#### R_D=1, S_D=1, Q=Q, ~Q=~Q (维持状态)

状态又上一个时间点的 Q, ~Q决定

这个也可以分析一下

#### R_D=0, S_D=0, Q=1, ~Q=1 (破坏互补输出关系)

这个状态还没太多的问题,

问题是: 假如下一个状态是R_D=1, S_D=1, 那么是维持这个状态

但是实际上, 我们的`S_D=1, R_D=1`要求的是Q与~Q互补

并且会让`S_D=1, R_D=1`的状态不知道

因此, 我们不能让`R_D, S_D`全0,

那么约束条件就是: R_D + S_D = 1

#### 记忆方法:

![zz](img/image_2023-10-23-11-03-06.png)

1. R_D=1, S_D=0 ("1状态")

可以理解为: set有效, reset无效, 那么Q=1, ~Q=0

2. R_D=0, S_D=1 ("0状态")

可以理解为: set无效, reset有效, 那么Q=0, ~Q=1

3. R_D=1, S_D=1 (维持)

可以理解为: set无效, reset无效,

既不set, 也不reset, 那么就是保持

4. R_D=0, S_D=0 (不可出现状态)

即set, 又reset, 那么就是不允许的

### 基本RS触发器功能描述方法

#### 1. 状态转移 真值表or次太卡诺图

![zz](img/image_2023-10-23-11-10-38.png)

#### 2. 特征方程

(确实是特征方程, 一阶差分)

有卡诺图, 就可以求出来逻辑表达式

![zz](img/image_2023-10-23-11-11-54.png)

#### 3. 状态转移图or激励表

真值表->状态转移图

![zz](img/image_2023-10-23-11-17-34.png)

状态转移图->激励表

![zz](img/image_2023-10-23-11-18-10.png)

#### 4. 时序图(波形图)

![zz](img/image_2023-10-23-11-31-53.png)

其中这里出现两次 "不允许输入状态"

#### 或非门的RS触发器

![zz](img/image_2023-10-23-11-32-29.png)

### 钟控RS触发器

时序电路中, 触发器的翻转时刻 受 时钟脉冲 控制

![zz](img/image_2023-10-23-11-36-11.png)

1. 当CP=0时, S_D, R_D锁死在1, 触发器维持
2. 当CP=1时, 由输入信号决定

真值表, 特征方程

![zz](img/image_2023-10-23-11-41-36.png)

状态转移图, 波形图

![zz](img/image_2023-10-23-11-43-51.png)

### D触发器, D锁存器

- CP=1
  - D=0 => S_D=1, R_D=0 => Q=0, ~Q=1 ("状态0")
  - D=1 => S_D=0, R_D=1 => Q=1, ~Q=0 (状态"1")
- CP=0
  - S_D=1, R_D=1 => Q^(n+1) = Q^n (维持)

特征方程

![zz](img/image_2023-10-23-11-51-33.png)

发现没有约束条件: 因为不存在有S_D=0, R_D=0的情况

状态表, 状态转移图, 激励表

![zz](img/image_2023-10-23-11-54-27.png)

由状态表观察可得: 时钟的作用下, 次太(始终)和输入保持一致

故D触发器, 又叫做D锁存器(latch)

### 钟控JK触发器

D触发器没有约束条件, JK触发器也是一种没有约束条件的触发器

![zz](img/image_2023-10-23-11-59-55.png)

1. 推导 特征方程

![zz](img/image_2023-10-23-12-02-23.png)

2. 状态表, 激励表

![zz](img/image_2023-10-23-12-07-19.png)

3. 状态转移图

![zz](img/image_2023-10-23-12-08-21.png)

- 当`J==K`的时候, 相当于RS触发器
- 当`J!=K`的时候, 相当于T触发器

### 钟控T触发器

![zz](img/image_2023-10-23-12-09-28.png)

封装上, 有点像D触发器

但是原理图, 有点像JK触发器, 只不过, 将J, K连在了一起, 也就是 T

1. 推导特征方程

![zz](img/image_2023-10-23-12-11-00.png)

输出信号: 次太 = T 异或 现太

2. 状态表, 状态转移图, 激励表

![zz](img/image_2023-10-23-12-12-20.png)

#### 钟控T'触发器

将T端固定到 高电平上, 或者是悬空, 也就是钟控T'触发器

1. CP = 1, 那么 Q^(n+1) = ~Q^(n)
2. CP = 0, 那么保持之前的状态

也就是, CP每作用一次, T'触发器就会翻转一次, 很适合用来计数

## CMOS触发器

现代工艺中, 门级触发器已经比较少用了.

总所周知, 内存条中一堆CMOS管, 也就是大多数用的是CMOS触发器

### COMS钟控触发器

![zz](img/image_2023-10-23-13-33-46.png)

传输管

![zz](img/image_2023-10-23-13-36-54.png)

这个电路的功能, 就是一个D触发器

实际上, 在集成电路中, 最常用的就是D触发器

优缺点

![zz](img/image_2023-10-23-13-38-40.png)

对于D触发器, 还可以理解成:

二选一mux

![zz](img/image_2023-10-23-13-39-10.png)

发现实际的COMS D触发器和二选一mux差不多(电路)

![zz](img/image_2023-10-23-13-40-36.png)

#### 时序图的画法

![zz](img/image_2023-10-23-13-43-12.png)

#### 抗干扰能力

接收时间 如果与 保持时间 一样长

那么就会导致 抗干扰能力弱

接收时间长了, 如果在最后的时刻, 信号发生了干扰,
那么就会导致接收的信息是错误的

如果接收在一瞬间完成, 那么出错的概率就比较小

![zz](img/image_2023-10-23-13-45-44.png)

这个是按照时钟信号的点位触发器的一个缺点

实际上, 我们不应该设计成mux那样的触发器

所以, 大多数情况下, 我们会设计成 "时钟边沿触发器"

### COMS边沿触发器

两种触发器:

- 锁存器latch, 电平触发(抗干扰能力弱)
- 寄存器register, 边沿触发

图形符号中, 如果是边沿触发, 会加一个小三角

效果:

![zz](img/image_2023-10-23-14-05-20.png)

抗干扰能力效果: 竞争, 冒险, 毛刺, 是否会传递到输出端

![zz](img/image_2023-10-23-14-07-17.png)

#### 原理(posedge)

主从结构, master slave

可以理解成: 数据流动, posedge, 在master为0, 在slave为1

![zz](img/image_2023-10-23-14-14-16.png)

#### 实际电路

![zz](img/image_2023-10-23-14-33-52.png)
