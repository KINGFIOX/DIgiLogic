---
id: "1-verilog入门"
aliases:
  - "1-verilog入门"
tags: []
---

# 1-verilog入门

### 0.注释

可以采用c风格的两种注释方式

```verilog
//
/**/
```

### 1. 数值表示

```verilog
4'b1011         // 4bit 数值
32'h3022_c0de   // 32bit 的数值
```

`4`表示4个bit, `'b`表示后面的数字是二进制的, 比方说`1011`

`'h`表示后面的数字是十六进制的, 比方说`3022_c0de`,
其中的`_`是只是一个表示, 是为了增强可读性的,
这个有点类似于C++17以后的字面量

`'d`表示十进制, 默认是十进制的, 比方说`counter = 100;`.
默认的位宽是`32bit`, 也就是上面是

#### 负数

负数`-6'd15`, 负数, 6个bits, 用十进制表示的15.
但是, 这样表示是错误的`4'd-2 //非法说明`

#### 实数

```verilog
30.123
6.0
3.0
0.001
```

#### 科学计数法

```verilog
1.2e4         //大小为12000
1_0001e4      //大小为100010000
1E-3          //大小为0.001
```

#### 字符串的表示方法

```verilog
reg [0: 14*8-1]       str ;
initial begin
    str = "www.runoob.com";
end
```

这行代码定义了一个名为`str`的寄存器变量，它被定义为一个16位宽、长度为112的向量。
`[0:14*8-1]`表示向量的范围，其中`0`是向量的最高位，`14*8-1`是向量的最低位。该向量可以用于存储二进制数据，例如字符串或数字等。在Verilog中，寄存器变量通常用于存储状态信息和中间结果。

### 2. 数据类型

#### 线wire

线网型还有其他数据类型，包括 wand，wor，wri，triand，trior，trireg 等

```verilog
wire   interrupt ;
wire   flag1, flag2 ;
wire   gnd = 1'b0 ;
```

#### 寄存器reg

寄存器（reg）用来表示存储单元，它会保持数据原有的值，直到被改写

```verilog
reg    clk_temp;
reg    flag1, flag2 ;
```

例如在 always 块中，寄存器可能被综合成边沿触发器，在组合逻辑中可能被综合成 wire 型变量。寄存器不需要驱动源，也不一定需要时钟信号。在仿真时，寄存器的值可在任意时刻通过赋值操作进行改写。例如：

> 边沿触发器是一种数字电路元件，可以在输入信号的上升沿或下降沿触发，并在触发后将输出状态保持不变一段时间。边沿触发器通常用于时序电路中，例如计数器、状态机等。常见的边沿触发器包括D触发器、JK触发器、T触发器等。这些触发器可以通过组合使用，实现各种复杂的逻辑功能。

```verilog
reg rstn ;
initial begin
    rstn = 1'b0 ;
    #100 ;
    rstn = 1'b1 ;
end
```

`#100`表示在仿真中暂停100个时间单位。在Verilog中，时间单位可以是纳秒、微秒或毫秒等。`#`符号用于控制仿真的时间流逝，可以在仿真过程中暂停一段时间，以便观察电路的行为。在这个例子中，`#100`表示在rstn变量被赋值为0后，暂停100个时间单位，然后再将rstn变量赋值为1。这个过程模拟了一个复位信号，即在电路刚启动时将rstn信号拉低一段时间，然后再将其拉高，以便电路可以正确地初始化。

#### 向量

```verilog
reg [3:0]      counter ;    //声明4bit位宽的寄存器counter
wire [32-1:0]  gpio_data;   //声明32bit位宽的线型变量gpio_data
wire [8:2]     addr ;       //声明7bit位宽的线型变量addr，位宽范围为8:2
reg [0:31]     data ;       //声明32bit位宽的寄存器变量data, 最高有效位为0
```

> `reg[0:31]`和`reg[31:0]`都是定义一个32位宽的寄存器变量，但它们的位顺序不同。`reg[0:31]`表示最高位在左侧，最低位在右侧，即从高位到低位依次排列；而`reg[31:0]`表示最高位在右侧，最低位在左侧，即从低位到高位依次排列。这两种写法在大多数情况下是等价的，但在某些特殊情况下，例如进行位操作时，它们的表现可能会有所不同。因此，在编写Verilog代码时，需要根据具体的应用场景选择合适的写法。

> 这个是不是有点类似于大小端的东西
> 是的，`reg[0:31]`和`reg[31:0]`的区别可以类比于大小端的概念。在大小端中，数据的存储顺序决定了字节的排列方式。大端序（big-endian）将高位字节存储在起始地址，而小端序（little-endian）将低位字节存储在起始地址。类似地，`reg[0:31]`表示最低位在右侧，最高位在左侧，类似于小端序；而`reg[31:0]`表示最高位在右侧，最低位在左侧，类似于大端序。这种区别在进行位操作时可能会产生不同的结果。
> 需要注意的是，大小端和寄存器位宽的定义方式有一些相似之处，但并不完全相同。大小端是指字节的存储顺序，而寄存器位宽定义则是指位的排列顺序。在Verilog中，寄存器位宽定义使用方括号表示范围，用于指定寄存器变量的位数和位顺序。

`wire [9:0]     data_low = data[0:9] ;`

> 第一段代码定义了一个名为data_low的线网变量，它被定义为一个10位宽的向量，其中[9:0]表示向量的范围。该向量将data变量的最低10位（即第0位到第9位）赋值给data_low变量。这种写法可以方便地从一个大向量中提取部分数据，以便进行后续的操作。

> `wire [9:0] data_low = data[0:9]`中的`[9:0]`和`[0:9]`是等价的，表示同一个向量。这是因为在Verilog中，向量的位顺序可以从高位到低位或从低位到高位依次排列，只要在定义时保持一致即可。例如，`[9:0]`和`[0:9]`都表示一个10位宽的向量，只是位顺序相反而已。在这个例子中，`data[0:9]`表示从最低位到第9位的10个位，而`wire [9:0] data_low = data[0:9]`则将这10个位赋值给了`data_low`变量的最低位到第9位。因此，这两种写法是等价的。

不懂, 还是有些奇怪

`addr_temp[3:2] = addr[8:7] + 1'b1 ;`

> 第二段代码将一个名为addr_temp的变量的第2位和第3位赋值为另一个名为addr的变量的第7位和第8位加上1。addr_temp[3:2]表示向量的范围，其中3:2表示从第3位到第2位的范围。这种写法可以方便地对向量中的部分位进行操作，例如提取、赋值、逻辑运算等。

```verilog
//下面 2 种赋值是等效的
A = data1[31-: 8] ;
A = data1[31:24] ;

//下面 2 种赋值是等效的
B = data1[0+ : 8] ;
B = data1[0:7] ;
```

向量拼接

```verilog
wire [31:0]    temp1, temp2 ;
assign temp1 = {byte1[0][7:0], data1[31:8]};  //数据拼接
assign temp2 = {32{1'b0}};  //赋值32位的数值0
```

#### 整数integer

#### 实数real

#### 时间time

#### 数组

```verilog
integer          flag [7:0] ; //8个整数组成的数组
reg  [3:0]       counter [3:0] ; //由4个4bit计数器组成的数组
wire [7:0]       addr_bus [3:0] ; //由4个8bit wire型变量组成的数组
wire             data_bit[7:0][5:0] ; //声明1bit wire型变量的二维数组
reg [31:0]       data_4d[11:0][3:0][3:0][255:0] ; //声明4维的32bit数据变量数组
```

#### 存储器

(类似于ram或者rom)

```verilog
reg               membit[0:255] ;  //256bit的1bit存储器
reg  [7:0]        mem[0:1023] ;    //1Kbyte存储器，位宽8bit
mem[511] = 8'b0 ;                  //令第512个8bit的存储单元值为0
```

#### 参数parameter

参数用来表示常量，用关键字 parameter 声明，只能赋值一次

```verilog
parameter      data_width = 10'd32 ;
parameter      i=1, j=2, k=3 ;
parameter      mem_size = data_width * 10 ;
```

#### 字符串

每个字符串占用一个字节(8bits)

```verilog
reg [0: 14*8-1]       str ;
initial begin
    str = "run.runoob.com";
end
```
